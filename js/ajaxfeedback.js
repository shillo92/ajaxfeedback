$(function() {
  /**
   * Version 0.3.1.
   */
  $.fn.extend({
      /**
       * Makes a jQuery element a messenger for JSON messages sent over AJAX.
       *
       * @param options You must specify a 'returnedData' option since it provides the data returned from the JSON response.
       * If you specify a `string` value, it will be used as the `returnedData` option.
       * @constructor
       * @throws If no 'returnedData' option specified.
       *         If JSON file could not be loaded.
       */
      ajaxFeedback : function (options) {
          if (typeof options === "string") {
              options = {
                  returnedData: options
              };
          }

          var settings = $.extend({
              /**
               * The data returned from the JSON response to the AJAX request.
               * Notice that a data-url/data-data attributes will override this setting.
               */
              returnedData : null,

              /**
               * Specify the number of seconds after which every message will be hidden. You can specify 0 (or any other
               * false value) if you do not want to hide it. Defaults to 5 seconds.
               */
              hideAfter : 5,

              /**
               * Maybe sounds a little scary but it's simply a method to create the HTML for the element that will contain
               * all the input messages.
               *
               * @param classname string. CSS classname generated by the plugin.
               * @returns {string} HTML string represents the input messages container.
               */
              formatMessagesContainer : function (classname) {
                  return '<ul class="'+classname+'"></ul>';
              },

              /**
               * Called each message iteration to create an HTML message.
               *
               * @param inputClassname string. CSS Classname generated by the plugin.
               * @param inputMessage string. The text message returned from the JSON response.
               * @returns {string} HTML string represents the message.
               */
              formatMessage : function (inputClassname, inputMessage) {
                  return '<li class="'+inputClassname+'">'+inputMessage+'</li>';
              },

              /**
               * Responsible for showing the message, by default shows it with a 'fadeIn' animation.
               *
               * This method is called in the context of the jQuery message element, therefore no parameters are passed.
               * Simply assume that 'this' is the jQuery message element.
               */
              messageShow : function () {
                  this.fadeIn();
              },

              /**
               * Responsible for hiding the message (usually after a delay of couple seconds),
               * by default hides it with a 'fadeOut'.
               *
               * This method is called in the context of the jQuery message element, therefore no parameters are passed.
               * Simply assume that 'this' is the jQuery message element.
               */
              messageHide : function () {
                  this.fadeOut();
              },

              /**
               * If specified, the data will be specified in this target element rather in this element.
               */
              target : null,

              /**
               * Will be used as part of each message class name.
               * Used in cases where a raw String is returned rather than array of messages, where the type of the message
               * cannot be told. By default "error" is used.
               */
              defaultMessageType : "error",

              /**
               * The name of the parameter returned from the JSON response (at the same level as the `messages` parameter),
               * indicates whether there was a good feedback or bad feedback.
               */
              successIndicatorParam: "success",

              /**
               * Triggered after successful feedback, meaning that the boolean `success` parameter in the JSON response
               * has positive (true) result.
               *
               * In the absence of success indicator parameter, this method will be triggered after every feedback.
               *
               * By default, this method does nothing.
               *
               * You can utilize the event.preventDefault in order to discontinue the functionality of ajaxfeedback.
               *
               * @param event jQuery 'ShowAjaxFeedback' event.
               * @param data The JSON data returned from the response.
               */
              onGoodFeedback: function(event, data) {
              },

              /**
               * Triggered after bad feedback, meaning that the boolean `success` parameter in the JSON response
               * has negative (false) result.
               *
               * By default, this method does nothing.
               *
               * You can utilize the event.preventDefault in order to discontinue the functionality of ajaxfeedback.
               *
               * @param event jQuery 'ShowAjaxFeedback' event.
               * @param data The JSON data returned from the response.
               */
              onBadFeedback: function(event, data) {
              }
          }, options);

          /**
           * Extracts the messages from a JSON result.
           *
           * @param data
           * @returns {*}
           * @constructor
           */
          var ExtractMessages = function (data) {
              return (data['messages']) ? data['messages'] : null;
          };

          /**
           * Resolves the state of the success indicator and dispatches of either onGoodFeedback or onBadFeedback.
           *
           * @param event jQuery event.
           * @param data The JSON data.
           * @constructor
           */
          var HandleSuccessIndicator = function(event, data) {
              var indicator = data[settings.successIndicatorParam];

              (indicator !== false) ? settings.onGoodFeedback(event, data) : settings.onBadFeedback(event, data);
          };

          var $this           = $(this);
          var returnedData    = settings.returnedData;
          var messageType     = settings.defaultMessageType;
          var dataUrl         = $this.data('url');
          var dataData        = $this.data('data');
          var dataMsgType     = $this.data('messagetype');
          var event           = $.Event('ShowAjaxFeedback');

          if (dataUrl) {
              $.ajax({
                  url: dataUrl,
                  dataType: 'json',
                  async: false,
                  success: function (data) {
                      returnedData = data;
                  },
                  error: function(jqxhr, message) {
                      throw "AjaxFeedback Could not load the JSON file, received the following message: "+message
                  }
              });
          } else if (dataData) {
              returnedData = dataData;
              messageType  = (dataMsgType) ? dataMsgType : messageType;
          } else if (!returnedData) {
              throw "You must specify a returnedData option in AjaxFeedback or data-url/data-data attributes.";
          }

          var messages = null;

          // If we got a raw string for messages, convert it to an object of messages we can work with
          if (typeof(returnedData) === "string") {
              messages = {};

              // Dynamically set the property of the returnedData
              messages[messageType] = {
                  "_" : [returnedData]
              }

              // Transform it into empty object so HandleSuccessIndicator() can handle it
              returnedData = {};
          } else {
              messages = ExtractMessages(returnedData);
          }

          HandleSuccessIndicator(event, returnedData);

          if (event.isDefaultPrevented()) {
              return;
          }

          var $target = (settings.target) ? $(settings.target) : $this;

          if (messages) {
              // Clear previous messages (if exist)
              $target.empty();

              $.each(messages, function (messagesType, inputMessages) {
                  // Using this classname it will be easier to style messages according to their type e.g: error,
                  // success, info
                  var classname = 'msg-'+messagesType+"-container";
                  var messagesContainerHtml = settings.formatMessagesContainer(classname);
                  var $messagesContainer = $(messagesContainerHtml).appendTo($target);

                  // inputMessages is array of messages attached to input element such as <input type="text" />
                  $.each(inputMessages, function (inputName, inputMessage) {
                      var inputClassname  = "msg-"+messagesType+" msg-input-"+inputName;
                      var msgHtml         = settings.formatMessage(inputClassname, inputMessage);
                      var show            = settings.messageShow;
                      var hide            = settings.messageHide;
                      var $msg            = $(msgHtml).hide().appendTo($messagesContainer);
                      var hideAfter       = settings.hideAfter * 1000; // Convert to milliseconds

                      // Show the element
                      show.call($msg);

                      // Hide the element after certain time or non at all
                      if (settings.hideAfter) {
                          setTimeout(function () {hide.call($msg);}, hideAfter)
                      }
                  });
              });
          }
      }
  });
}) (jQuery);
